package actions

import (
	"encoding/json"
	"errors"
	"evm-trackooor/shared"
	"evm-trackooor/utils"
	"fmt"
	"log"
	"math/big"
	"os"
	"os/exec"
	"slices"
	"strings"
	"sync"
	"time"

	"github.com/dominikbraun/graph"
	"github.com/dominikbraun/graph/draw"
	"github.com/ethereum/go-ethereum/common"
)

// notes for testing
// direct funding:
// go run main.go track historical blocks --config ./config_tornado_withdraw_deploy.json --from-block 13499614
// 2 transfers:
// go run main.go track historical blocks --config ./config_tornado_withdraw_deploy.json --from-block 20214530

// logging
var tornadoLog *log.Logger

// custom config data
var tornadoOptions struct {
	discordWebhook       shared.WebhookInstance
	dataFilepath         string
	ethTransferThreshold *big.Int
	maxEthTransferDepth  int
	dataRetentionPeriod  time.Duration // how long to keep edge data for
}

// action data
var tornadoFundedAddresses map[common.Address]fundedAddressData

var tornadoContracts []common.Address

var tornadoMutex sync.RWMutex // mutex for `tornadoFundedAddresses` map
var discordMutex sync.RWMutex // mutex so discord msgs are sent in order

type fundedAddressData struct {
	FundedActions []fundedAction `json:"funded-actions"`
	// transfer eth depth, 0 depth would be direct withdrawal from Tornado.Cash, 1 would be transfer from a depth 0 address etc.
	Depth int `json:"depth"`
}

type fundedAction struct {
	// funded through tornado withdraw
	WithdrawTxHash      common.Hash    `json:"withdraw-tx-hash"`
	TornadoContract     common.Address `json:"tornado-contract"`
	TornadoContractName string         `json:"tornado-contract-name"`
	// funded through transfers from other addresses which were funded by tornado
	TransferTxHash common.Hash    `json:"transfer-tx-hash"`
	FromAddress    common.Address `json:"from-address"`
	Value          *big.Int       `json:"value"`

	Timestamp time.Time `json:"time"` // not exact
}

func (actionInfo) InfoTrackTornadoFundDeploy() actionInfo {
	name := "TrackTornadoFundDeploy"
	overview := "Tracks Tornado.cash withdrawers and ether transfers by withdrawers. " +
		"Alerts if tracked address deploys a contract."

	description := "This is done by listening to withdraw events of all Tornado.cash contracts, " +
		"and adding the withdraw `to` field to tracked addresses. " +
		"Ether transfers from tracked addresses will add the ether recipient to tracked addresses. " +
		"Any subsequent contract deployments will alert in the webhook and terminal."

	options := `"data-filepath" - path to save data to
"webhook-url" - Discord webhook URL for alerts
"eth-transfer-threshold" - Min amount of eth transfers to an address for it to be tracked, units in wei
"max-eth-transfer-depth" - Maximum depth to keep tracking eth transfers
"data-retention-period" - Will only consider data in the last X hours. Note that data won't be deleted, but only deployments that had a funding path less than this time will be logged`

	example := `"TrackTornadoFundDeploy": {
    "addresses": {
        "0x12D66f87A04A9E220743712cE6d9bB1B5616B8Fc": {"name": "Tornado.Cash 0.1 ETH"},
    },
    "options":{
        "webhook-url":"https://discord.com/api/webhooks/...",
        "data-filepath":"./tornado_data.json",
        "eth-transfer-threshold":"1000000000000000000",
        "max-eth-transfer-depth":3,
        "data-retention-period":"24h"
    }
}`

	return actionInfo{
		ActionName:          name,
		ActionOverview:      overview,
		ActionDescription:   description,
		ActionOptionDetails: options,
		ActionConfigExample: example,
	}
}

// logs addresses that withdraw from tornado, then deploy a contract
// works by listening to all tornado contracts for withdraw events
// provided addresses to this action should be the tornado contract addresses
func (p action) InitTrackTornadoFundDeploy() {
	// init maps
	tornadoFundedAddresses = make(map[common.Address]fundedAddressData)

	// init logging
	tornadoLog = shared.TimeLogger("[Tornado] ")

	// get and set custom options
	setTornadoOptions(p)

	// load previously saved data file (if exists)
	if _, err := os.Stat(tornadoOptions.dataFilepath); err == nil {
		// data file exists, load previous data
		dat, err := os.ReadFile(tornadoOptions.dataFilepath)
		if err != nil {
			panic(err)
		}

		// load JSON data
		tornadoMutex.Lock()
		err = json.Unmarshal(dat, &tornadoFundedAddresses)
		if err != nil {
			panic(err)
		}
		tornadoLog.Printf("Loaded previous data, tracking %v addresses\n", len(tornadoFundedAddresses))
		// add previous data addresses to tracking
		for address := range tornadoFundedAddresses {
			addTxAddressAction(address, processTornadoWithdrawerTx)
		}
		tornadoMutex.Unlock()

	} else if errors.Is(err, os.ErrNotExist) {
		// data file does not exist, all good
	} else {
		panic(err)
	}

	// track all tornado contracts for withdrawal events
	tornadoContracts = p.o.Addresses
	for _, tornadoContract := range tornadoContracts {
		addAddressEventSigAction(
			tornadoContract,
			"Withdrawal(address,bytes32,address,uint256)",
			processTornadoWithdrawEvent,
		)
	}
}

func setTornadoOptions(p action) {
	// get data filepath
	if v, ok := p.o.CustomOptions["data-filepath"]; ok {
		tornadoOptions.dataFilepath = v.(string)
	} else {
		uniswapV2Log.Fatal("Data filepath (\"data-filepath\") not specified!")
	}
	tornadoLog.Printf("Using data file %v\n", tornadoOptions.dataFilepath)

	// get discord webhook url
	if v, ok := p.o.CustomOptions["webhook-url"]; ok {
		webhookUrl := v.(string)
		tornadoOptions.discordWebhook = shared.WebhookInstance{
			WebhookURL:           webhookUrl,
			Username:             "evm trackooor",
			Avatar_url:           "",
			RetrySendingMessages: true,
		}
		tornadoLog.Printf("Using discord webhook URL %v\n", webhookUrl)
	}

	// get eth transfer threshold
	if v, ok := p.o.CustomOptions["eth-transfer-threshold"]; ok {
		tornadoOptions.ethTransferThreshold = big.NewInt(0)
		var ok2 bool
		tornadoOptions.ethTransferThreshold, ok2 = tornadoOptions.ethTransferThreshold.SetString(v.(string), 10)
		if !ok2 {
			tornadoLog.Fatalf("Could not set tornadoOptions.ethTransferThreshold, invalid big int value %v\n", v)
		}
	} else {
		tornadoOptions.ethTransferThreshold = big.NewInt(50000000000000000)
		tornadoLog.Printf("No eth transfer threshold specified, using default\n")
	}
	tornadoLog.Printf(
		"Using eth transfer threshold of %v wei (%v ether)\n",
		tornadoOptions.ethTransferThreshold,
		utils.FormatDecimals(tornadoOptions.ethTransferThreshold, 18),
	)

	// get max eth transfer depth
	if v, ok := p.o.CustomOptions["max-eth-transfer-depth"]; ok {
		tornadoOptions.maxEthTransferDepth = int(v.(float64))
		tornadoLog.Printf("Using max eth transfer depth of %v\n", tornadoOptions.maxEthTransferDepth)
	} else {
		tornadoLog.Printf("Max eth transfer depth not set, defaulting to 3\n")
		tornadoOptions.maxEthTransferDepth = 3
	}

	// get data retention period
	if v, ok := p.o.CustomOptions["data-retention-period"]; ok {
		s := v.(string)
		duration, err := time.ParseDuration(s)
		if err != nil {
			tornadoLog.Fatalf("Invalid time duration %v\n", s)
		}
		tornadoOptions.dataRetentionPeriod = duration
	} else {
		tornadoLog.Printf("No data retention period specified, using default\n")
		tornadoOptions.dataRetentionPeriod = time.Hour * 24 * 1 // 1 day
	}
	tornadoLog.Printf("Using data retention period of %v\n", tornadoOptions.dataRetentionPeriod)
}

// save tornado funded address data to data file
func updateDataFile() {
	tornadoMutex.RLock()
	raw, err := json.Marshal(tornadoFundedAddresses)
	tornadoMutex.RUnlock()
	if err != nil {
		panic(err)
	}

	err = os.WriteFile(tornadoOptions.dataFilepath, raw, 0644)
	if err != nil {
		panic(err)
	}
}

// called when withdraw event emitted from any tornado contract
func processTornadoWithdrawEvent(p ActionEventData) {
	// get where tornado funds were sent to
	withdrawTo := p.DecodedData["to"].(common.Address)

	// track address funds were sent to for transactions
	addTxAddressAction(withdrawTo, processTornadoWithdrawerTx)

	// record withdraw tx, tornado contract
	tornadoContract := p.EventLog.Address

	tornadoContractName := "unknown"
	if v, ok := shared.Options.AddressProperties[tornadoContract]; ok {
		tornadoContractName = v["name"].(string)
	}

	fundedAction := fundedAction{
		WithdrawTxHash:      p.EventLog.TxHash,
		TornadoContract:     tornadoContract,
		TornadoContractName: tornadoContractName,
		Timestamp:           time.Now(),
	}

	tornadoMutex.RLock()
	fundedActions := append(tornadoFundedAddresses[withdrawTo].FundedActions, fundedAction)
	tornadoMutex.RUnlock()

	fundedAddressData := fundedAddressData{
		FundedActions: fundedActions,
		Depth:         0, // direct withdraw from tornado contracts
	}

	tornadoMutex.Lock()
	tornadoFundedAddresses[withdrawTo] = fundedAddressData
	tornadoMutex.Unlock()

	tornadoLog.Printf(
		"Withdrawal to %v from %v (%v)\n",
		withdrawTo,
		tornadoContract,
		tornadoContractName,
	)

	updateDataFile()
}

func processTornadoFundedTransfer(p ActionTxData) {
	// check if tornado funded address transferred ether
	from := *p.From

	tornadoMutex.RLock()
	if funder, ok := tornadoFundedAddresses[from]; ok { // tx originates from tornado funded address
		tornadoMutex.RUnlock()

		value := p.Transaction.Value()
		to := *p.To
		if value.Cmp(tornadoOptions.ethTransferThreshold) >= 0 { // transferred >=threshold ETH
			// calculate depth of new address (minimum depth out of all transfers)
			// lets call `from` the 'funder address' and `to` the `funded address`
			// we cannot simply set new depth to funder depth + 1, because there could be
			// other funders that had a lower depth. therefore we need to loop through
			// all the funders and get the min depth, then set funded depth to min depth + 1
			depth := tornadoOptions.maxEthTransferDepth + 1
			minDepth := tornadoOptions.maxEthTransferDepth
			tornadoMutex.RLock()
			funded := tornadoFundedAddresses[to]
			// if there are no actions, set depth to funder depth + 1
			if len(funded.FundedActions) == 0 {
				depth = funder.Depth + 1
			} else {
				// otherwise, loop through actions that funded the funded address
				for _, fundedAction := range funded.FundedActions {
					// if funded address was directly funded by tornado contract, set depth to 0 and stop
					if fundedAction.TornadoContract.Cmp(shared.ZeroAddress) != 0 {
						depth = 0
						break
					}
					// otherwise, get depth of funder
					funderVar := tornadoFundedAddresses[fundedAction.FromAddress]
					funderDepth := funderVar.Depth
					if funderDepth < minDepth {
						minDepth = funderDepth
						depth = minDepth + 1
					}
				}
			}

			tornadoMutex.RUnlock()

			// ignore and don't track further if depth exceeds max depth
			if depth > tornadoOptions.maxEthTransferDepth {
				return
			}

			tornadoLog.Printf(
				"Funded address %v transferred %v ETH to %v (depth %v)\n",
				from,
				utils.FormatDecimals(value, 18),
				to,
				depth,
			)
			// track address ETH was sent to
			addTxAddressAction(to, processTornadoWithdrawerTx)
			// record where funds came from for `to` address
			fundedAction := fundedAction{
				TransferTxHash: p.Transaction.Hash(),
				FromAddress:    from,
				Value:          value,
				Timestamp:      time.Now(),
			}

			tornadoMutex.RLock()
			fundedActions := append(tornadoFundedAddresses[to].FundedActions, fundedAction)
			tornadoMutex.RUnlock()

			fundedAddressData := fundedAddressData{
				FundedActions: fundedActions,
				Depth:         depth,
			}

			tornadoMutex.Lock()
			tornadoFundedAddresses[to] = fundedAddressData
			tornadoMutex.Unlock()

			updateDataFile()
		}
	} else {
		tornadoMutex.RUnlock()
	}
}

// called when a previous address which withdrew from tornado
// sends/receives a transactions
func processTornadoWithdrawerTx(p ActionTxData) {
	isDeployment := utils.IsDeploymentTx(p.Transaction)

	if isDeployment {
		processTornadoFundedDeployment(p)
	} else {
		processTornadoFundedTransfer(p)
	}
}

func processTornadoFundedDeployment(p ActionTxData) {

	if p.From == nil {
		tornadoLog.Printf("p.From is nil, ignoring txhash %v\n", p.Transaction.Hash())
		return
	}

	// tornado funded address deploys contract - this is suspicious, potential exploit attempt? log it
	deployer := *p.From
	deployedContract, err := shared.GetDeployedContractAddress(p.Transaction)
	if err != nil {
		tornadoLog.Printf("Failed to get deployed contract address of tx hash: %v err: %v\n", p.Transaction.Hash(), err)
		return
	}

	// we will ignore if the funded address are too deep
	// this is so if depth changes (to smaller depth) in config, those that are too deep will stop sending alerts
	tornadoMutex.RLock()
	fundedAddress := tornadoFundedAddresses[deployer]
	tornadoMutex.RUnlock()
	if fundedAddress.Depth > tornadoOptions.maxEthTransferDepth {
		return
	}

	// we will also ignore if the address funding took longer than `dataRetentionPeriod`
	fundingDuration := getFundingDuration(deployer, time.Now(), []time.Duration{}, 0)
	//DEBUG
	fmt.Printf("deployment detected, addr: %v fundingDuration: %v\n", deployer, fundingDuration)
	if fundingDuration > tornadoOptions.dataRetentionPeriod {
		// funding path time elapsed too long, ignore
		return
	}

	// mark deployed contract as 'funded' by the deployer
	fundedAction := fundedAction{
		TransferTxHash: p.Transaction.Hash(),
		FromAddress:    deployer,
		Value:          p.Transaction.Value(),
		Timestamp:      time.Now(),
	}

	tornadoMutex.RLock()
	fundedActions := append(tornadoFundedAddresses[deployedContract].FundedActions, fundedAction)
	tornadoMutex.RUnlock()

	fundedAddressData := fundedAddressData{
		FundedActions: fundedActions,
	}

	// assign to map
	tornadoMutex.Lock()
	tornadoFundedAddresses[deployedContract] = fundedAddressData
	tornadoMutex.Unlock()

	tornadoMutex.RLock() // read lock everything just in case
	// output to terminal
	logSusDeploymentTerminal(p, deployer, deployedContract)

	// output to discord webhook
	logSusDeploymentDiscord(p, deployer, deployedContract, fundingDuration)
	tornadoMutex.RUnlock()
}

// returns the minimum time it took to fund an address (all the way from tornado.cash contracts)
// returns dataRetentionPeriod*2 if all of the times were too long
func getFundingDuration(target common.Address, prevTime time.Time, times []time.Duration, depth int, alreadyProcessed ...common.Address) time.Duration {
	// loop through how an address was funded
	// if its tornado.cash then get time elapsed for the total funding time
	// then take and return minimum of `times` for the mine time

	alreadyProcessed = append(alreadyProcessed, target)

	fundedActions := tornadoFundedAddresses[target].FundedActions

	var addrTime map[time.Duration]common.Address
	addrTime = make(map[time.Duration]common.Address)

	if depth > tornadoOptions.maxEthTransferDepth {
		return tornadoOptions.dataRetentionPeriod * 2
	}

	for _, fundedAction := range fundedActions {
		// do not process future transfers
		// e.g. A is funded in April by B
		// B is funded in March by C, and in June by D
		// we shouldn't consider the funding by D as it is after A was funded
		if fundedAction.Timestamp.After(prevTime) {
			continue
		}

		if fundedAction.TornadoContract != shared.ZeroAddress {
			// tornado.cash
			// record elapsed time
			elapsedTime := time.Since(fundedAction.Timestamp)
			times = append(times, elapsedTime)

		} else {
			// intermidiary address

			// avoid infinite recursion if cyclic funding
			funder := fundedAction.FromAddress
			if slices.Contains(alreadyProcessed, funder) {
				continue
			}
			alreadyProcessed = append(alreadyProcessed, funder)

			// ignore if already too long
			elapsedTime := time.Since(fundedAction.Timestamp)
			if elapsedTime > tornadoOptions.dataRetentionPeriod {
				continue
			}

			addrTime[elapsedTime] = funder

			// recurse
			times = append(times, getFundingDuration(funder, fundedAction.Timestamp, times, depth+1, alreadyProcessed...))
		}
		// reduce
		minTime := slices.Min(times)
		times = []time.Duration{minTime}

		minTimeAddress := addrTime[minTime]
		fmt.Printf("minTime: %v minTimeAddress: %v\n", minTime, minTimeAddress)

	}
	if len(times) == 0 {
		return tornadoOptions.dataRetentionPeriod * 2
	}
	return slices.Min(times)
}

func logSusDeploymentTerminal(p ActionTxData, deployer common.Address, deployedContract common.Address) {
	fundedAddress := tornadoFundedAddresses[deployer]
	tornadoLog.Printf(
		"SUSPICIOUS ACTIVITY:\n"+
			"address %v previously withdrew from tornado.cash and deployed a contract\n",
		deployer,
	)
	tornadoLog.Printf("previous withdrawals:\n")
	for _, action := range fundedAddress.FundedActions {
		jsonDump, err := json.Marshal(action)
		if err != nil {
			panic(err)
		}
		tornadoLog.Printf(string(jsonDump) + "\n")
	}
	tornadoLog.Printf("deployed contract: %v\n", deployedContract)
}

func logSusDeploymentDiscord(p ActionTxData, deployer common.Address, deployedContract common.Address, fundingDuration time.Duration) {
	discordMutex.Lock()
	defer discordMutex.Unlock()

	fundedAddressVar := tornadoFundedAddresses[deployer]

	// discord info msg
	tornadoOptions.discordWebhook.SendMessage(fmt.Sprintf(
		"## Detected withdrawal from tornado.cash then contract deployment\n"+
			"Deployer address: %v (depth %v)\n"+
			"Deployed contract: %v, %v\n"+
			"Funding duration: %v\n",
		utils.FormatBlockscanHyperlink("address", utils.ShortenAddress(deployer), deployer.Hex()),
		fundedAddressVar.Depth,
		utils.FormatBlockscanHyperlink("address", utils.ShortenAddress(deployedContract), deployedContract.Hex()),
		utils.FormatBlockscanHyperlink("transaction", "tx hash", p.Transaction.Hash().Hex()),
		fundingDuration,
	))
	tornadoOptions.discordWebhook.SendMessage("**Fundings from tornado.cash / intermediary addresses:**\n")

	// generate graph and send both funding logs and graph

	g := graph.New(common.Address.Hex, graph.Directed())
	// colour deployer node
	g.AddVertex(
		deployer,
		graph.VertexAttribute("label", utils.ShortenAddress(deployer)+" (Deployer)"),
		graph.VertexAttribute("colorscheme", "ylorbr3"),
		graph.VertexAttribute("style", "filled"),
		graph.VertexAttribute("color", "2"),
		graph.VertexAttribute("fillcolor", "1"),
	)
	// colour deployed contract node
	g.AddVertex(
		deployedContract,
		graph.VertexAttribute("label", utils.ShortenAddress(deployedContract)+" (Deployed contract)"),
		graph.VertexAttribute("colorscheme", "blues3"),
		graph.VertexAttribute("style", "filled"),
		graph.VertexAttribute("color", "2"),
		graph.VertexAttribute("fillcolor", "1"),
	)
	// generate funding path from deployed contract
	recursivePopulateGraph(&g, deployedContract, 0)

	// remove 'floating' vertexes (that don't show direct withdrawal from tornado.cash)
	removeFloatingVertexes(&g, deployer)

	// convert graph to png image
	graphFilename := "/tmp/tempgraph.gv"
	graphImgFilename := graphFilename + ".png"
	file, _ := os.Create(graphFilename)
	_ = draw.DOT(g, file)

	cmd := exec.Command("dot", "-Tpng", "-O", graphFilename)
	stdout, err := cmd.Output()
	if err != nil {
		tornadoLog.Printf("Error when generating graph: %v stdout: %v\n", err, stdout)
		// return
	} else {
		tornadoLog.Printf("Generated graph image to %v\n", graphImgFilename)
	}

	// send funding logs to discord
	var fundingLogs []string
	recursivelyGetFundingLogFromGraph(&fundingLogs, &g, deployedContract)

	// send markdown text file containing funding path (graph edges)
	err = tornadoOptions.discordWebhook.SendFile(
		[]byte(strings.Join(fundingLogs, "\n")),      // file data
		fmt.Sprintf("%v_funding_paths.md", deployer), // filename
	)
	if err != nil {
		tornadoLog.Printf("Error when sending funding path txt to discord: %v\n", err.Error())
		// return
	}

	// send image to discord
	imgData, _ := os.ReadFile(graphImgFilename)
	err = tornadoOptions.discordWebhook.SendFile(imgData, graphImgFilename)
	if err != nil {
		tornadoLog.Printf("Error when sending graph to discord: %v\n", err.Error())
		return
	} else {
		tornadoLog.Printf("Send graph image %v to discord\n", graphImgFilename)
	}
}

// given graph g and address that was funded, will traverse back up until tornado.cash funding.
// edge.Data will hold the value (*big.Int) of the transfer if from intermediary address.
// if funded from tornado, edge.Data (int) will hold number of withdrawals for that edge.
// we use `alreadyGraphedTxHashes` to prevent double-counting transfers, in case node traverses back to itself.
func recursivePopulateGraph(_g *graph.Graph[string, common.Address], fundedAddress common.Address, fundedAddressDepth int, alreadyLogged ...common.Address) {
	g := *_g

	fundedAddressVar := tornadoFundedAddresses[fundedAddress]
	// do not log if funded address is too deep
	if fundedAddressVar.Depth > tornadoOptions.maxEthTransferDepth {
		return
	}

	for _, fundedAction := range fundedAddressVar.FundedActions {
		// do not add if time transfer time exceeds data retention period
		if time.Since(fundedAction.Timestamp) > tornadoOptions.dataRetentionPeriod {
			// DEBUG
			// fmt.Printf("GRAPH IGNORING %v timestamp %v\n", fundedAction.FromAddress, fundedAction.Timestamp)
			continue
		}

		if fundedAction.TornadoContract.Cmp(shared.ZeroAddress) == 0 {
			// funding was from intermediary address
			funder := fundedAction.FromAddress
			value := fundedAction.Value

			// make sure funder not already processed
			if slices.Contains(alreadyLogged, fundedAction.FromAddress) {
				continue
			}

			// do not add if funder address is too deep
			if fundedAddressDepth > tornadoOptions.maxEthTransferDepth {
				continue
			}

			// check if edge already exists
			edge, err := g.Edge(funder.Hex(), fundedAddress.Hex())
			if err == graph.ErrEdgeNotFound {
				// edge does not already exist
				// add edge
				valueStr := utils.FormatDecimals(value, 18) + " ETH"
				g.AddVertex(funder, graph.VertexAttribute("label", utils.ShortenAddress(funder)))
				g.AddEdge(
					funder.Hex(),                           // from
					fundedAddress.Hex(),                    // to
					graph.EdgeAttribute("label", valueStr), // label
					graph.EdgeData(value),                  // data (type *big.Int)
				)

				// recurse to graph how the funder was funded
				alreadyLogged = append(alreadyLogged, funder)
				recursivePopulateGraph(_g, funder, fundedAddressDepth+1, alreadyLogged...)
			} else {
				// edge already exists
				// update edge data
				newData := big.NewInt(0).Add(edge.Properties.Data.(*big.Int), value)
				_ = g.UpdateEdge(funder.Hex(), fundedAddress.Hex(), graph.EdgeData(newData))
				// update edge label
				// warning: do not query `edge.Properties.Data.(*big.Int)` as it will not be updated
				// (if you wanted to, you would need to retrieve edge again)
				valueStr := utils.FormatDecimals(newData, 18) + " ETH"
				edge.Properties.Attributes["label"] = valueStr
			}
		} else {
			// funding was from tornado.cash directly
			funder := fundedAction.TornadoContract
			amountStr := strings.TrimPrefix(fundedAction.TornadoContractName, "Tornado.Cash ")

			// check if edge already exists
			edge, err := g.Edge(funder.Hex(), fundedAddress.Hex())
			if err == graph.ErrEdgeNotFound {
				// edge does not already exist
				// dont recurse as it is from tornado.cash directly
				// colour vertex (as its from tornado.cash)
				g.AddVertex(
					funder,
					graph.VertexAttribute("label", fundedAction.TornadoContractName),
					graph.VertexAttribute("colorscheme", "greens3"),
					graph.VertexAttribute("style", "filled"),
					graph.VertexAttribute("color", "2"),
					graph.VertexAttribute("fillcolor", "1"),
				)
				// add edge
				g.AddEdge(
					funder.Hex(),                            // from
					fundedAddress.Hex(),                     // to
					graph.EdgeAttribute("label", amountStr), // label
					graph.EdgeData(int(1)),                  // data (type int)
				)
			} else {
				// edge already exists
				// update edge data
				newData := edge.Properties.Data.(int) + 1
				_ = g.UpdateEdge(funder.Hex(), fundedAddress.Hex(), graph.EdgeData(newData))
				// update edge label
				// e.g. 10 ETH * 2
				// warning: do not query `edge.Properties.Data.(int)` as it will not be updated
				// (if you wanted to, you would need to retrieve edge again)
				newLabel := fmt.Sprintf("%v * %v", amountStr, newData)
				edge.Properties.Attributes["label"] = newLabel
			}
		}
	}
}

// remove vertexes that don't show a path to tornado.cash
// do this by traversing upwards from deployer, checking if the current address
func removeFloatingVertexes(_g *graph.Graph[string, common.Address], currentNode common.Address, alreadyDone ...common.Address) {
	g := *_g

	// traversed to topmost (tornado contract), stop
	if currentNode.Cmp(shared.ZeroAddress) == 0 {
		return
	}

	var upwardNodes []common.Address
	alreadyDone = append(alreadyDone, currentNode)

	for _, action := range tornadoFundedAddresses[currentNode].FundedActions {
		if !slices.Contains(alreadyDone, action.FromAddress) {
			upwardNodes = append(upwardNodes, action.FromAddress)
		}
	}

	pathToTornado := false
	for _, tornadoContract := range tornadoContracts {
		_, err := graph.ShortestPath(g, tornadoContract.Hex(), currentNode.Hex())
		if err != nil {
			continue
		}
		pathToTornado = true
	}

	// fmt.Printf("currentNode: %v\n", currentNode)
	// fmt.Printf("pathToTornado: %v\n", pathToTornado)
	// fmt.Printf("upwardNodes: %v\n", upwardNodes)

	// current node has path to tornado. traverse up
	if pathToTornado {
		for _, node := range upwardNodes {
			removeFloatingVertexes(_g, node, alreadyDone...)
		}
	} else {
		// otherwise, remove current node and all nodes pointing to it
		// fmt.Printf("removing %v\n", currentNode)
		removeNodeFromGraph(_g, currentNode.Hex())
	}
}

func removeNodeFromGraph(_g *graph.Graph[string, common.Address], node string) {
	g := *_g
	allEdges, _ := g.Edges()
	for _, edge := range allEdges {
		if edge.Source == node {
			g.RemoveEdge(edge.Source, edge.Target)
		}
		if edge.Target == node {
			// if edge points up we need to remove upward ones too
			g.RemoveEdge(edge.Source, edge.Target)
			removeNodeFromGraph(_g, edge.Source)
		}
	}

	g.RemoveVertex(node)
}

// only traverses upwards (incoming edges)
func recursivelyGetFundingLogFromGraph(buffer *[]string, _g *graph.Graph[string, common.Address], fundedAddress common.Address) {
	g := *_g

	fundedAddressVar := tornadoFundedAddresses[fundedAddress]
	// loop through all ways this node was funded, if the edge exists in the graph then we add funding log to buf
	for _, fundedAction := range fundedAddressVar.FundedActions {
		if fundedAction.TornadoContract.Cmp(shared.ZeroAddress) == 0 {
			// funding was from intermediary address
			funder := fundedAction.FromAddress
			// check if edge exists
			_, err := g.Edge(funder.Hex(), fundedAddress.Hex())
			if err == graph.ErrEdgeNotFound {
				continue
			}
			// add to funding log
			*buffer = append(*buffer, fmt.Sprintf(
				"%v received %v ETH from %v (depth %v), %v\n",
				utils.FormatBlockscanHyperlink("address", utils.ShortenAddress(fundedAddress), fundedAddress.Hex()),
				utils.FormatDecimals(fundedAction.Value, 18),
				utils.FormatBlockscanHyperlink("address", utils.ShortenAddress(funder), funder.Hex()),
				fundedAddressVar.Depth,
				utils.FormatBlockscanHyperlink("transaction", "tx hash", fundedAction.TransferTxHash.Hex()),
			))

			// recurse by checking how funder was funded
			recursivelyGetFundingLogFromGraph(buffer, _g, funder)
		} else {
			// funding was from tornado.cash
			funder := fundedAction.TornadoContract
			// check if edge exists
			_, err := g.Edge(funder.Hex(), fundedAddress.Hex())
			if err == graph.ErrEdgeNotFound {
				continue
			}
			// add to funding log and don't recurse
			*buffer = append(*buffer, fmt.Sprintf(
				"%v withdrew from %v, %v\n",
				utils.FormatBlockscanHyperlink("address", utils.ShortenAddress(fundedAddress), fundedAddress.Hex()),
				utils.FormatBlockscanHyperlink("address", fundedAction.TornadoContractName, funder.Hex()),
				utils.FormatBlockscanHyperlink("transaction", "tx hash", fundedAction.WithdrawTxHash.Hex()),
			))
		}
	}
}
